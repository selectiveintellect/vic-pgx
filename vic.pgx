%grammar vic
%version 0.0.6
#COPYRIGHT: 2014 Vikas N Kumar <vikas@cpan.org>. All Rights Reserved

# uc-select is necessary.
program: uc-select header* statement* EOS

header: uc-config | comment
uc-select: /PIC <BLANK>+ (<uc-types>) <line-ending>/

# P16F690X is fake just to show how to enumerate.
uc-types: /(?i:P16F690 | P16F690X)/
uc-config: /config/ + (name | variable) config-expression line-ending
config-expression: name /<EQUAL> -/ (number-units | number) -

comment: /- <HASH> <ANY>* <EOL>/ | blank-line
blank-line: /- <EOL>/

##FIXME: this needs to be removed really but Pegex has a bug
_: /<BLANK>*/
__: /<BLANK>+/
line-ending: /- <SEMI> - <EOL>?/

statement: comment | instruction | expression | block

block: start-block statement* end-block
start-block: name /- <LCURLY> - <EOL>?/
end-block: /- <RCURLY> - <EOL>?/

instruction: name values line-ending

name: - identifier -
values: (value % COMMA)*
value: - (string | number-units | number | variable | block | validated-variable | modifier-variable) -

expression: lhs-op-rhs | lhs-op | op-rhs | conditional
lhs-op: - variable - incdec-operator /- <SEMI>? - <EOL>?/
op-rhs: - incdec-operator - variable /- <SEMI>? - <EOL>?/
complement: - complement-operator - variable -
expr-value: - (number | variable | number-units | complement | modifier-variable) -
rhs-expr: (expr-value % rhs-operator)*
lhs-op-rhs: - variable - assign-operator - rhs-expr line-ending

comparison: expr-value compare-operator expr-value
single-conditional: comparison | complement
conditional-predicate-double: - block - COMMA - block line-ending
conditional-predicate-single: - block line-ending
conditional-predicate: conditional-predicate-double | conditional-predicate-single
conditional-subject: (single-conditional % logic-operator)*
conditional: conditional-subject - COMMA - conditional-predicate

string: single-quoted-string | double-quoted-string

# most microcontrollers cannot do floating point math so ignore real numbers
number-units: number - units
# number handles both hex and non-hex values for ease of use
number: /(0[xX]<HEX>+ | <DIGIT>+)/
units: /(s | ms | us | kHz | Hz | MHz)/

validated-variable: identifier
modifier-variable: identifier -  variable
variable: DOLLAR identifier
identifier: /(<ALPHA>[<WORDS>]*)/

complement-operator: /(<TILDE> | <BANG>)/
incdec-operator: /(<PLUS> <PLUS> | <DASH> <DASH>)/
assign-operator: /([<PLUS> <DASH> <PERCENT> <CARET> <STAR> <PIPE> <AMP> <SLASH>]? <EQUAL>)/
compare-operator: /([<BANG> <EQUAL> <LANGLE> <RANGLE>] <EQUAL> | (: <LANGLE> | <RANGLE> ))/
logic-operator: /([<AMP> <PIPE>]{2})/
math-operator: /([<PLUS> <DASH> <STAR> <SLASH> <PERCENT>])/
bit-operator: /([<PIPE> <CARET> <AMP>])/
rhs-operator: math-operator | bit-operator
# parentheses
start-expr-block: /- <LPAREN> -/
end-expr-block: /- <RPAREN> -/

single_quoted_string:
    /(:
        <SINGLE>
        ((:
            [^<BREAK><BACK><SINGLE>] |
            <BACK><SINGLE> |
            <BACK><BACK>
        )*?)
        <SINGLE>
    )/

double_quoted_string:
    /(:
        <DOUBLE>
        ((:
            [^<BREAK><BACK><DOUBLE>] |
            <BACK><DOUBLE> |
            <BACK><BACK> |
            <BACK><escape>
        )*?)
        <DOUBLE>
    )/

escape: / [0nt] /
